<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fun Project from Bharat Thapa</title>
    <link rel="stylesheet" href="css/styles.css">
</head>

<body>

    <canvas id="space"></canvas>

    <header>
        <nav class="primary-nav">
            <ul class="navigation">
                <li id="js">JS</li>
                <li id="dom">DOM</li>
                <li id="projects">Projects</li>
            </ul>
        </nav>
    </header>

    <main>
        <div id="js">
            <h1>JavaScript</h1>
            <section class="content">
                <div class="topic-wrapper">
                    <div class="topic-heading">
                        <h2>Introduction (JavaScript & EcmaScript)</h2>
                    </div>
                    <div class="topic-description" style="display: none;">
                        <p>JavaScript is a programming language used to build interactive and dynamic websites. It works
                            alongside HTML and CSS to control a webpage's behavior, such as:</p>
                        <ul>
                            <li>Showing or hiding elements</li>
                            <li>Validating form inputs</li>
                            <li>Fetching data from servers</li>
                            <li>Creating animations</li>
                            <li>Handling user events like clicks or keystrokes</li>
                        </ul>
                        <p>JavaScript code is executed directly in the web browser, making it a client-side language.
                            However, with environments like Node.js, JavaScript can also run on servers (server-side).
                        </p>
                        <p>Key Uses of JavaScript:</p>
                        <ul>
                            <li>Web interactivity: Slideshows, modals, dropdowns, etc.</li>
                            <li>Single Page Applications (SPAs): Using frameworks like React, Vue, or Angular.</li>
                            <li>Server-side development: With Node.js (e.g., building APIs).</li>
                            <li>Mobile & Desktop Apps: Using tools like React Native or Electron.</li>
                            <li>Game Development: Lightweight browser games using canvas and WebGL.</li>
                        </ul>

                        <h3>What is ECMAScript (ES)?</h3>
                        <p>ECMAScript (ES) is the standard specification for JavaScript, defined by ECMA International.
                            JavaScript is an implementation of this specification. ECMAScript defines:</p>
                        <ul>
                            <li>Syntax rules</li>
                            <li>Core features (like variables, functions, classes, modules)</li>
                            <li>New updates (ES6, ES7, ES2020, etc.)</li>
                            <li>For example: let, const, arrow functions (()=>{}), template strings (`Hello ${name}`),
                                and class syntax were introduced in ES6 (2015).</li>
                        </ul>

                        <p>Example:</p>

                        <pre>
                            <code>
                                // example of onClick event handling (in a button)
                                &lt;button onclick="greet()"&gt;Click Me&lt;/button&gt;

                                &lt;script&gt;
                                    function greet() {
                                        alert('Hello, world!');
                                    }
                                &lt;/script&gt;
                            </code>
                        </pre>

                        <span>When the user clicks the button, the JavaScript greet() function runs and shows an
                            alert.</span>
                    </div>
                </div>

                <div class="topic-wrapper">
                    <div class="topic-heading">
                        <h2>Creating Variables</h2>
                    </div>
                    <div class="topic-description" style="display: none;">
                        <p>A variable in JavaScript is used to store data that you can reuse or modify later.</p>

                        <h3>Declaring Variables</h3>
                        <p>You can declare variables using:</p>
                        <ul>
                            <li>var (old, mostly avoided now)</li>
                            <li>let (modern, block-scoped). Use it if you need to re-assign the value later.</li>
                            <li>const (modern, block-scoped and constant). Use it if the value doesn't need to re-assign
                                later.</li>
                        </ul>

                        <h3>Best practice for variables</h3>

                        <ul>
                            <li>Give meaningful names to variables</li>
                            <li>Don't start names with [0-9]</li>
                            <li>Don't use reserved keywords. Example: this, for, if, class, …</li>
                            <li>Allowed keys: [aA-zZ], [0-9], and _ (underscore)</li>
                            <li>Variable names are case sensitive so make sure you name them properly and use proper
                                identifier.</li>
                            <li>Best practice is to declare one variable per line.</li>
                        </ul>

                        <h3>Types:</h3>
                        <p>Value Types:</p>
                        <ul>
                            <li>string</li>
                            <li>number</li>
                            <li>boolean</li>
                            <li>undefined</li>
                            <li>null</li>
                        </ul>
                        <p>Referece Types:</p>
                        <ul>
                            <li>objects</li>
                            <li>arrays</li>
                        </ul>

                        <h3>Statically typed Vs. Dynamically typed:</h3>
                        <ul>
                            <li>Statically typed language need to declare variables along with their types</li>
                            <li>Dynamically typed language can change their variable type during run time.</li>
                        </ul>

                        <h3>Variable scope:</h3>
                        <ul>
                            <li>var: function scoped</li>
                            <li>let/const: block scoped (conditional block, loop block, function)</li>
                        </ul>

                        <h3>typeof Operator</h3>
                        <p>Use typeof to check the type of a variable.</p>

                        <h3>Hoisting:</h3>
                        <p>Variables and functions are moved to the top of their scope before code execution (JS moves
                            declarations to the top).</p>
                        <p>Function expressions are not hoisted with value</p>

                        <h3>Closures</h3>
                        <p>A closure formed is when a function remembers the variables from its outer scope, even after
                            that scope has closed.</p>
                        <p>Closures Are Used In: Data privacy (like private variables), Factory functions, Event
                            handlers, setTimeout, setInterval, React hooks (especially useState and useEffect)</p>

                        <p>Example:</p>
                        <pre>
                            <code>
                                // Hoisting example.
                                sayHello();  // ❌ TypeError: sayHello is not a function
                                // sayHello is a function expression.
                                var sayHello = function() {
                                    console.log("Hello");
                                };

                                // closure example:
                                function outer() {
                                    let count = 0;

                                    return function inner() {
                                        count++;
                                        console.log(count);
                                    };
                                }

                                const counter = outer();
                                counter(); // 1
                                counter(); // 2
                                counter(); // 3
                            </code>
                        </pre>
                    </div>
                </div>

                <div class="topic-wrapper">
                    <div class="topic-heading">
                        <h2>Operators</h2>
                    </div>
                    <div class="topic-description" style="display: none;">
                        <p>An operator is a symbol used to perform operations on variables and values — like arithmetic,
                            comparison, logic, etc.</p>

                        <h3>Arithmetic Operators</h3>
                        <p>Used for basic math</p>
                        <ul>
                            <li>+ (addition)</li>
                            <li>- (substraction)</li>
                            <li>* (multiplication)</li>
                            <li>/ (division): 5 / 2 = 2.5</li>
                            <li>% (modulus): 5 % 2 = 1</li>
                            <li>** (exponentiation): 2 ** 3 = 8</li>
                            <li>++ (increment)</li>
                            <li>-- (decrement)</li>
                        </ul>

                        <h3>Assignment Operators</h3>
                        <p>Assign values to variables</p>
                        <ul>
                            <li>=</li>
                            <li>+=</li>
                            <li>-=</li>
                            <li>*=</li>
                            <li>/=</li>
                            <li>%=</li>
                            <li>**=</li>
                        </ul>

                        <h3>Comparison Operators:</h3>
                        <p>Return true or false.</p>
                        <ul>
                            <li>== (equal loose)</li>
                            <li>=== (equal strict)</li>
                            <li>!= (not equal)</li>
                            <li>!==</li>
                            <li>>, <,>=, <= </li>
                        </ul>

                        <h3>Logical Operators:</h3>
                        <p>Used to combine conditions.</p>
                        <ul>
                            <li>&& (AND)</li>
                            <li>|| (OR)</li>
                        </ul>

                        <h3>Type Operators</h3>
                        <ul>
                            <li>typeof</li>
                            <li>instanceof</li>
                        </ul>

                        <h3>String Operators:</h3>
                        <ul>
                            <li>+ : let fullName = firstName + ' ' + 'lastName;</li>
                        </ul>

                        <h3>Ternary Operator (? :)</h3>
                        <p>let result = condition ? true_value : default_or_false_value;</p>

                        <h3>Nullish Coalescing Operator (??)</h3>
                        <p>Returns the right-hand value if the left-hand is null or undefined.</p>

                        <p>let name = null ?? "Guest"; // "Guest" </p>
                        <p>let count = 0 ?? 10; // 0 ✅ (not null)</p>

                        <h3>Optional Chaining (?.)</h3>
                        <p>Safely access nested properties without errors.</p>

                        <h3>Spread (...) and Rest (...) Operators</h3>
                        <p>let arr1 = [1, 2]; </p>
                        <p>let arr2 = [...arr1, 3]; // [1, 2, 3];</p>

                        <pre>
                            function sum(...nums) {
                                return nums.reduce((a, b) => a + b);
                            }
                        </pre>
                    </div>
                </div>

                <div class="topic-wrapper">
                    <div class="topic-heading">
                        <h2>Control Flow (Loops and Conditionals)</h2>
                    </div>
                    <div class="topic-description" style="display: none;">
                        <p>Control Flow is the order in which code is executed in a program. JavaScript runs code from
                            top to bottom, unless you change the flow using conditions, loops, or jumps.</p>

                        <h3>Conditional Statements</h3>
                        <p>Used to execute different blocks of code based on conditions.</p>
                        <ul>
                            <li>if</li>
                            <li>else if</li>
                            <li>else</li>
                            <li>switch</li>
                        </ul>

                        <h3>Loops</h3>

                        <ul>
                            <li>for</li>
                            <li>while</li>
                            <li>do...while</li>
                        </ul>

                        <h3>Loop Control: break and continue:</h3>
                        <ul>
                            <li>break → exits the loop early</li>
                            <li>continue → skips current iteration</li>
                        </ul>

                        <h3>Early Return in Functions:</h3>
                        <p>Exit early to avoid unnecessary logic.</p>


                        <h3>&& and || trick</h3>
                        <ul>
                            <li>&&: execute only if the condition matches. Example: condition &&
                                execute_this_block_or_func</li>
                            <li>||: execute default block or func if the condition isn't met. Example: condition ||
                                default_call_or_val</li>
                        </ul>

                        <p>Example:</p>
                        <pre>
                            <code>
                                let isLoggedIn = true;
                                isLoggedIn && console.log("Welcome!"); // shortcut for if

                                let userName = null;
                                let displayName = userName || "Guest"; // fallback value

                                let age = 18;
                                let status = (age >= 18) ? "Adult" : "Minor";
                            </code>
                        </pre>

                        <span>Note: in loops, make sure to set a proper condition to exit. Otherwise, infinite loop can
                            happen.</span>
                    </div>
                </div>

                <div class="topic-wrapper">
                    <div class="topic-heading">
                        <h2>Arrow Function</h2>
                    </div>
                    <div class="topic-description" style="display: none;">
                        <p>Arrow functions (=>) are a shorter way to write functions in JavaScript introduced in ES6
                            (2015).
                            But they're not just shorter — they behave differently, especially with keyword <span
                                style='font-style: italic; font-weight: bold;'>this</span>.</p>

                        <pre>
                            <code>
                                // basic function!
                                function greet(name) {
                                   return "Hello " + name;
                                }

                                // arrow function.
                                const greet = (name) => {
                                    return "Hello " + name;
                                };

                                // or even shorter.
                                const greet = name => "Hellow " + name;

                                // multiple parameters.
                                const add = (a, b) => a + b;

                                // no parameters
                                const sayHi = () => "Hi!";

                                // Multiline Function Body
                                const multiply = (a, b) => {
                                    const result = a * b;
                                    return result;
                                };
                            </code>
                        </pre>

                        <h3>Some Information:</h3>
                        <ul>
                            <li>If there's only one parameter, you can omit parentheses.</li>
                            <li>If there's only one expression (function body), you can omit {} and return.</li>
                            <li>Always use () if you have 0 or more than 1 parameter.</li>
                            <li>In a block body ({}), you MUST use return explicitly.</li>
                        </ul>

                        <h3>Important: this Binding Difference</h3>

                        <ul>
                            <li>Arrow functions do NOT have their own this.</li>
                            <li>They inherit this from the surrounding scope (called lexical this)</li>
                        </ul>

                        <pre>
                            <code>
                                // regular 'this'
                                const person = {
                                    name: "Bharat",
                                    greet: function() {
                                        console.log("Hi, I'm " + this.name); // ✅ this = person
                                    }
                                };

                                // arrow 'this' (won't work)
                                const person = {
                                    name: "Bharat",
                                    greet: () => {
                                        console.log("Hi, I'm " + this.name); // ❌ this = undefined / window
                                    }
                                };

                                // correct use of 'this': notice we wrapped in regular function (where 'this' refers to object).
                                const person = {
                                    name: "Bharat",
                                    greet: function() {
                                        setTimeout(() => {
                                            console.log("Hi " + this.name); // ✅ this = person
                                        }, 1000);
                                    }
                                };
                            </code>
                        </pre>

                        <h3>Common Use Cases of Arrow Functions:</h3>
                        <ul>
                            <li>Callbacks</li>
                            <li>In .map(), .filter(), .reduce()</li>
                        </ul>

                        <h3>Where NOT to Use Arrow Functions:</h3>
                        <ul>
                            <li>Object methods: this will be wrong</li>
                            <li>Constructors (new): Arrow funcs can’t be used as constructors</li>
                            <li>Prototype methods: Same issue with as object methods.</li>
                            <li>Event listeners (sometimes): You may need correct this (e.g., DOM element)</li>
                        </ul>

                        <h3>Use Case Tips</h3>
                        <ul>
                            <li>Inside methods: use regular functions</li>
                            <li>Inside setTimeout, setInterval: use arrow if you want this from parent</li>
                            <li>Implicit return of object literals → wrap in ()</li>
                        </ul>
                        <pre>
                            <code>
                                const user = {
                                    name: "Ram",
                                    greet() {
                                        console.log(this.name); // ✅ works
                                    }
                                };

                                setTimeout(() => {
                                    console.log(this); // parent context
                                }, 1000);

                                // if you need to return an object from an one liner arrow function, user ().
                                const getUser = () => ({ name: "Bharat", age: 30 });

                            </code>
                        </pre>

                        <p>Note: "Lexical" means "defined by position in the source code".</p>

                    </div>
                </div>

                <div class="topic-wrapper">
                    <div class="topic-heading">
                        <h2>Destructuring</h2>
                    </div>
                    <div class="topic-description" style="display: none;">
                        <p>Destructuring is a syntax in JavaScript that lets you unpack values from arrays or properties
                            from objects into separate variables — in one line.</p>

                        <h3>Array Destructuring</h3>
                        <pre>
                            <code>
                                const numbers = [10, 20, 30];
                                const [a, b, c] = numbers;

                                console.log(a); // 10
                                console.log(b); // 20

                                // Skipping Items
                                const [first, , third] = [1, 2, 3];
                                console.log(first); // 1
                                console.log(third); // 3

                                // Swapping Values
                                let x = 1, y = 2;
                                [x, y] = [y, x];
                                console.log(x, y); // 2, 1

                                // With Rest Operator
                                const [head, ...rest] = [1, 2, 3, 4];
                                console.log(head); // 1
                                console.log(rest); // [2, 3, 4]
                            </code>
                        </pre>

                        <h3>Object Destructuring:</h3>

                        <pre>
                            <code>
                                const user = { name: "Bharat", age: 25 };
                                const { name, age } = user;

                                console.log(name); // "Bharat"
                                console.log(age);  // 25

                                // Renaming Variables
                                const { name: fullName, age: years } = user;
                                console.log(fullName); // "Bharat"

                                // Default Values
                                const { country = "Nepal" } = user;
                                console.log(country); // "Nepal"

                                // Nested Destructuring
                                const user = {
                                    name: "Ram",
                                    address: {
                                        city: "Kathmandu",
                                        zip: 44600
                                    }
                                };
                                const { address: { city, zip } } = user;
                                console.log(city); // "Kathmandu"

                                // Destructuring in Function Parameters (React Component props)
                                function greet({ name, age }) {
                                    console.log(`Hello ${name}, age ${age}`);
                                }
                                const person = { name: "Hari", age: 30 };
                                greet(person); // Hello Hari, age 30

                                // Destructuring in Loops
                                const users = [
                                    { id: 1, name: "Bharat" },
                                    { id: 2, name: "Thapa" }
                                ];

                                for (const { id, name } of users) {
                                    console.log(`${id}: ${name}`);
                                }
                            </code>
                        </pre>

                        <h3>Tips:</h3>
                        <ul>
                            <li>object destructuring is based on property names, not position so order doesn't matter.
                            </li>
                            <li>Variable names must match property names (unless you rename) (for object destructuring)
                            </li>
                            <li>Arrays are ordered collections, so destructuring array is based on index position.</li>
                            <li>You can skip values using commas (in array destructuring)</li>
                        </ul>
                    </div>
                </div>

                <div class="topic-wrapper">
                    <div class="topic-heading">
                        <h2>'this' Keyword</h2>
                    </div>
                    <div class="topic-description" style="display: none;">
                        <p>In JavaScript, <span style="font-weight: bold; font-style: italic;">this</span> is a keyword
                            that refers to the object that is executing the current function.</p>
                        <p>Its value depends on how and where the function is called, not just where it's written.</p>

                        <h3>Notes:</h3>
                        <ul>
                            <li>Value of 'this' in Global scope:</li>
                            <ul>
                                <li>strict mode: undefined</li>
                                <li>non strict mode: window (in browser) and global in node env.</li>
                            </ul>
                            <li>Inside object's method 'this' refers to the object.</li>
                            <li>if you call 'this' from normal function, 'this' refers to global object (window or
                                global)</li>
                            <li>'this' inside Event listener refers to the element that fired the event.</li>
                            <li>When this is called inside methods that are not part of the object, it will reference
                                the global object.</li>
                        </ul>

                        <pre>
                            <code>
                                // this in Global Scope
                                console.log(this); // In browser: window

                                // strict mode using 'use strict'
                                "use strict";
                                console.log(this); // undefined

                                // this in Functions
                                function show() {
                                    console.log(this);
                                }
                                show(); // non-strict: window | strict: undefined

                                // this Inside an Object Method
                                const person = {
                                    name: "Bharat",
                                    greet() {
                                        console.log(this.name);
                                    }
                                };

                                person.greet(); // "Bharat" ✅ (this = person)

                                // this with Arrow Functions
                                const person = {
                                    name: "Bharat",
                                    greet: () => {
                                        console.log(this.name);
                                    }
                                };

                                person.greet(); // ❌ undefined (arrow function has no `this`)

                                // 'this' called from methods that are not part of the object.
                                const video = {
                                    title: 'Video Title',
                                    tags: [ 'a', 'b', 'c', 'd' ],
                                    play: function(){
                                        console.log( 'this inside play', this ); // will reference video!
                                    },
                                    showTags: function(){
                                        this.tags.forEach( function( tag ){
                                            // this will reference the global object in this case!
                                            // if you use arrow function here, it will inherit the scope from parent method "showtags" and 'this' work correctly
                                            console.log( 'this inside forEach method', this );
                                        } );
                                    }
                                };

                                // this in Constructor Functions
                                function Person(name) {
                                    this.name = name;
                                    this.greet = function() {
                                        console.log( 'hello ' + name );
                                    };
                                }
                                const p = new Person("John");
                                console.log(p.name); // "John" (this refers to the new object being created)
                                p.greet(); // references Person

                                const newFunction = p.greet;
                                newFunction(); // this call is not part of the object now (i.e., like object.funcName() ) and 'this' won't refer to Person obj. It refers to global/window obj.

                                // to fix above : option 1 is to use .bind()
                                const newFunction = p.greet.bind(p);
                                newFunction(); // hello John

                                // option 2 is to use arrow function in Person constructor function.
                                this.greet = () => console.log( 'hello ' + name);
                                // now without even the .bind() call, newFunction() will work as expected.
                                
                                // this in Classes
                                class Car {
                                    constructor(name) {
                                        this.name = name;
                                    }

                                    start() {
                                        console.log(`${this.name} started`);
                                    }
                                }

                                const c = new Car("Toyota");
                                c.start(); // "Toyota started"
                            </code>
                        </pre>

                        <h3>this with call(), apply(), and bind()</h3>
                        <p>Used to manually control what 'this' refers to.</p>
                        <ul>
                            <li>call(): Calls the function immediately, and lets you pass arguments one-by-one.</li>
                            <li>apply(): Like call(), but arguments are passed as an array.</li>
                            <li>bind(): Returns a new function with this permanently set — but does NOT call it
                                immediately.</li>
                            <ul>
                                <li>Once bound using bind(), this cannot be changed again using call or apply.</li>
                            </ul>
                        </ul>

                        <pre>
                            <code>
                                // call() → immediately calls with custom this
                                function greet() {
                                    console.log(this.name);
                                }
                                greet.call({ name: "John" }); // "John"

                                // apply() → like call() but with arguments as array
                                greet.apply({ name: "Ram" }); // "Ram"

                                // bind() → returns a new function with bound this
                                const bound = greet.bind({ name: "Hari" });
                                bound(); // "Hari"
                            </code>
                        </pre>

                        <h3>'this' in DOM Event Handlers</h3>
                        <pre>
                            <code>
                                document.querySelector("button").addEventListener("click", function () {
                                    console.log(this); // ✅ the &lt;button&gt; element
                                });

                                // But with arrow function:
                                document.querySelector("button").addEventListener("click", () => {
                                    console.log(this); // ❌ not button, inherited from outer scope (usually window)
                                });
                            </code>
                        </pre>

                        <p>Note: Use arrow functions only when you want to preserve this</p>
                    </div>
                </div>

                <div class="topic-wrapper">
                    <div class="topic-heading">
                        <h2>Objects</h2>
                    </div>
                    <div class="topic-description" style="display: none;">
                        <p>A JavaScript object is a collection of key-value pairs (properties + methods).</p>

                        <h3>Creating Objects:</h3>
                        <ul>
                            <li>Object literal</li>
                            <li>new Object()</li>
                            <li>Factory function (returns obj structured from arguments)</li>
                            <li>Constructor function (uses 'this' keyword)</li>
                            <li>Class syntax</li>
                        </ul>

                        <pre>
                            <code>
                                // object example:
                                const user = {
                                    name: "Bharat",
                                    age: 25,
                                    greet() {
                                        console.log(`Hello, ${this.name}`);
                                    }
                                };

                                // Object literal
                                const person = { name: "Ram", age: 30 };
                                // Note: you can't use arrow function with 'this' to define a method inside an object literal.
                                // like:
                                // const person = { ..., someFunc: () => .. accessing 'this' here (fxn. body) is not correct., }; // 'this' won't refer to the object.
                                // good:
                                const person = {
                                    name: 'John',
                                    greet: function() {
                                        console.log( 'hello ' + this.name );
                                    }
                                };
                                // or:
                                const person = {
                                    name: 'John',
                                    greet: () => console.log( 'hello ' + person.name ) // using this.name would be wrong!
                                };

                                // creating object using 'new' keyword
                                const person = new Object();
                                person.name = "Ram";

                                // Factory function
                                function createUser(name, age) {
                                    return { name, age };
                                }

                                // Constructor function
                                // first empty obj {} is created. value of 'this' is made to point to that object. Finally object is returned (implicitly).
                                function Person(name) {
                                    this.name = name;
                                }
                                const p = new Person("John");

                                // class syntax
                                class Car {
                                    constructor(brand) {
                                        this.brand = brand;
                                    }
                                }
                            </code>
                        </pre>

                        <h3>Accessing Properties & Methods</h3>
                        <ul>
                            <li>Dot notation: user.name;</li>
                            <li>Bracket notation: user["name"];</li>
                            <ul>
                                <li>can also access special keys: user["full-name"]</li>
                                <li>can also access dynamic keys: user[keyName]</li>
                            </ul>
                            <li>Calling methods: objectName.funcName();</li>
                            <li>Objects are Dynamic in Nature: We can add, delete, and update object properties and
                                methods by default.
                            </li>
                            <li>Delete property: delete user.age;</li>
                            <li>Check existence: 'in' keyword ('propertyName' in objectName) or
                                objectName.hasOwnProperty('propName') syntax.</li>
                            <li>Looping through objects: for .. in loop. </li>
                            <li>Use Object.keys(), Object.values(), or Object.entries() for better control</li>
                            <li>Object Utility Methods: .keys(obj), .values(), .entries(), .assign(), .freeze(),
                                .seal(), .hasOwn()</li>
                            <ul>
                                <li>Object.keys(obj): Returns array of keys</li>
                                <li>Object.values(obj): Returns array of values</li>
                                <li>Object.entries(obj): Returns array of [key, value]</li>
                                <li>Object.assign(target, src): Copies properties</li>
                                <li>Object.freeze(obj): Makes object immutable</li>
                                <li>Object.seal(obj): Prevents adding/removing properties</li>
                                <li>Object.hasOwn(obj, key): Safe key check</li>
                            </ul>
                        </ul>

                        <pre>
                            <code>                              
                                // Check existence
                                "name" in user;        // true
                                user.hasOwnProperty("name"); // true                                

                                // looping obj.
                                for (let key in user) {
                                    console.log(key, user[key]);
                                }

                                Object.keys(user);    // ['name', 'city']
                                Object.values(user);  // ['Bharat', 'Kathmandu']
                                Object.entries(user); // [['name', 'Bharat'], ['city', 'Kathmandu']]

                                // dynamic key
                                const key = "city";
                                const user = {
                                    [key]: "Lalitpur"
                                };
                            </code>
                        </pre>

                        <h3>Constructor Property and Prototype</h3>
                        <p>Every object in JavaScript has a property called constructor that references the function
                            used to create that object.</p>

                        <p>All objects in JS inherit from a hidden object called [[Prototype]] (accessed via __proto__
                            or Object.getPrototypeOf()).</p>

                        <p>When it (constructor property) tries to determine the function, first it looks for a custom
                            constructor (as in constructor function for creating objects) and if there is no custom
                            constructor function used then, it will return the native (built-in) function used to create
                            that object.</p>
                        <pre>
                            <code>
                                const obj = {}; // constructor: Object()
                                const str =  'string val'; // constructor: String()
                                const num = 123; // constructor: Number()
                                …

                                const obj = {};
                                console.log(obj.constructor); // ƒ Object() {...}

                                const arr = [];
                                console.log(arr.constructor); // ƒ Array() {...}

                                // So, the .constructor tells you: "What function was used to create this object?"

                                const obj = {};
                                console.log(obj.__proto__ === Object.prototype); // true

                                // Custom Constructor
                                function Person(name) {
                                    this.name = name;
                                }

                                const p = new Person("Bharat");
                                console.log(p.constructor); // ƒ Person(name) {...}
                                // The object p was created using Person(), so its .constructor points to Person.

                                // Recreate Objects
                                function clone(obj) {
                                    return new obj.constructor();
                                }

                                const date = new Date();
                                const newDate = clone(date);

                                // Restore Constructor after Prototype Override
                                // correct approach:
                                Person.prototype = {
                                    constructor: Person,
                                    greet() {
                                        console.log("Hi");
                                    }
                                };

                                // incorrect approach:
                                function Person() {}
                                Person.prototype = {
                                    greet() {
                                        console.log("Hi");
                                    }
                                };

                                const p = new Person();
                                console.log(p.constructor); // ❌ Object (not Person)
                            </code>
                        </pre>

                    </div>
                </div>

                <div class="topic-wrapper">
                    <div class="topic-heading">
                        <h2>Functions</h2>
                    </div>
                    <div class="topic-description" style="display: none;">
                        <p>A function is a reusable block of code designed to perform a particular task.</p>

                        <h3>Notes:</h3>
                        <ul>
                            <li>Functions are Hoisted — can be called before definition.</li>
                            <li>Function expressions are Not hoisted — only usable after definition.</li>
                            <li>Without return, function returns undefined</li>
                            <li>Functions create local scope.</li>
                            <li>Recursion: A function that calls itself.</li>
                            <li>First-Class Functions: JS Functions are first class. Meaning they can be:</li>
                            <ul>
                                <li>assigned to variables,</li>
                                <li>passed as arguments,</li>
                                <li>returned from other functions.</li>
                            </ul>
                            <li>Higher-Order Functions: A function that takes another function as an argument or returns
                                a function. Example: map, filter, forEach, setTimeout</li>
                        </ul>

                        <pre><code>
                            // example of a simple function
                            add(1, 2); // valid because of hoisting
                            function add(a, b){
                                return a + b;
                            }
                            add(2, 4);

                            // function expression (anonymous)
                            addNums(2, 3); // invalid because "function expression are not hoisted" 
                            const addNums = function(a, b) {
                                return a + b;
                            };
                            addNums(1, 3); //valid

                            // function expression (named).
                            const addNamed = function add(a, b){
                                return a + b;
                            }
                            addNamed(2, 3); // valid
                            const sum = addNamed;
                            sum(3, 4); // valid because JS functions are first class.

                            // Here you can also use arrow functions in fxn. expressions.

                        </code></pre>

                        <h3>Function Expression Vs. Function Declaration</h3>
                        <ul>
                            <li>In function expression, you can't call the function before it's definition.</li>
                            <li>It's because JavaScript doesn't hoist variables. And function expressions are just like
                                variable definitions except that the value is a function type instead of value (number,
                                string, …).</li>
                        </ul>

                        <h3>Hoisting</h3>
                        <p>Process in which JavaScript moves all the function definitions to the top of the file. With
                            this process, it's perfectly okay to call the function before its declaration unlike
                            function expressions which are similar to variables</p>

                        <p>Note: ES6 classes are not hoisted similar to variables</p>

                        <h3>Function Arguments and The Rest Operator</h3>
                        <p>argument is a property available inside functions that holds all the arguments supplied to
                            that function.</p>

                        <pre><code>
                            function sum(){
                                console.log( arguments );
                            }

                            // 'arguments' Object
                            function show() {
                                console.log(arguments);
                            }
                            show(1, 2, 3); // [1, 2, 3]
                            // Note: arguments object is not available in arrow functions.

                            // Rest Parameters
                            function sum(...nums) {
                                return nums.reduce((a, b) => a + b, 0);
                            }
                        </code></pre>

                        <h3>IIFE (Immediately Invoked Function Expression)</h3>
                        <p>Used to create private scopes in older JS</p>
                        <pre><code>
                            (function() {
                                console.log("Runs immediately");
                            })();

                            // bind(), call(), apply()
                            greet.call(obj, arg1, arg2);

                            greet.apply(obj, [arg1, arg2]);

                            const fn = greet.bind(obj);
                            fn();

                            // Function Length & Name
                            function greet(name, age) {}
                            console.log(greet.length); // 2 (number of declared params)
                            console.log(greet.name);   // "greet"
                        </code></pre>

                        <h3>Getters and Setters</h3>
                        <p>They're special functions that look like properties — used to get and set values in a clean,
                            controlled way.</p>
                        <p>They allow you to run logic when accessing or changing an object's property.</p>
                        <p>Why Use Them?</p>
                        <ul>
                            <li>Hide internal details</li>
                            <li>Add validation</li>
                            <li>Make computed values look like regular properties</li>
                            <li>Create reactive behavior (used heavily in frameworks like Vue, MobX)</li>
                        </ul>
                        <p>Getter: Must return a value</p>
                        <p>Setter: Must take exactly 1 parameter</p>
                        <p>Getter & Setter work in Object literals & ES6 classes</p>


                        <pre><code>
                            const user = {
                                firstName: "Bharat",
                                lastName: "Thapa",

                                get fullName() {
                                    return `${this.firstName} ${this.lastName}`;
                                },

                                set fullName(value) {
                                    const [first, last] = value.split(" ");
                                    this.firstName = first;
                                    this.lastName = last;
                                }
                            };

                            console.log(user.fullName); // "Bharat Thapa" ✅
                            user.fullName = "Ram Bahadur";
                            console.log(user.firstName); // "Ram"
                            console.log(user.lastName);  // "Bahadur"

                            // get makes fullName look like a property, but it's a function in disguise
                            // set allows fullName to be assigned like a value, but again — it's a function inside

                            // syntax:
                            let obj = {
                                get propName() {
                                    // runs when obj.propName is accessed
                                },
                                set propName(value) {
                                    // runs when obj.propName = value is assigned
                                }
                            };

                            // class
                            class Circle {
                                constructor(radius) {
                                    this._radius = radius;
                                }

                                get diameter() {
                                    return this._radius * 2;
                                }

                                set diameter(value) {
                                    this._radius = value / 2;
                                }
                            }

                            const c = new Circle(10);
                            console.log(c.diameter); // 20 ✅
                            c.diameter = 30;
                            console.log(c); // _radius is now 15 ✅
                        </code></pre>
                    </div>
                </div>

                <div class="topic-wrapper">
                    <div class="topic-heading">
                        <h2>OOP in JS</h2>
                    </div>
                    <div class="topic-description" style="display: none;">
                        <p>Object-Oriented Programming (OOP) is a coding style where you model real-world things using
                            objects.</p>
                        <p>OOP is based on 4 pillars:</p>
                        <ul>
                            <li>Encapsulation: Bundle data + behavior in one unit (object/class)</li>
                            <li>Abstraction: Hide internal complexity, show only what’s necessary</li>
                            <li>Inheritance: One object/class can inherit features from another</li>
                            <li>Polymorphism: Same method behaves differently on different objects</li>
                        </ul>

                        <p>JS is prototype-based, not class-based originally — but ES6 introduced class syntax to make
                            it feel more traditional.</p>

                        <pre><code>
                            // Prototypes and Inheritance
                            function Person(name, age) {
                                this.name = name;
                                this.age = age;
                                this.greet = function () {
                                    console.log("Hi, I'm " + this.name);
                                };
                            }

                            const p1 = new Person("Ram", 20);
                            p1.greet(); // Hi, I'm Ram

                            Person.prototype.sayAge = function () {
                                console.log(this.age);
                            };

                            p1.sayAge(); // 20

                            // The Modern Way — ES6 Classes
                            class Person {
                                constructor(name, age) {
                                    this.name = name;
                                    this.age = age;
                                }

                                greet() {
                                    console.log(`Hi, I'm ${this.name}`);
                                }
                            }

                            const p = new Person("Hari", 35);
                            p.greet(); // Hi, I'm Hari

                            // Under the hood, ES6 classes uses prototypes, but the syntax is cleaner
                        </code></pre>

                        <h3>Inheritance with extends</h3>
                        <p>you can override methods to create polymorphism</p>

                        <pre><code>
                            class Animal {
                                constructor(name) {
                                    this.name = name;
                                }

                                speak() {
                                    console.log(`${this.name} makes a noise`);
                                }
                            }

                            class Dog extends Animal {
                                speak() {
                                    console.log(`${this.name} barks`);
                                }
                            }

                            const d = new Dog("Tommy");
                            d.speak(); // Tommy barks
                        </code></pre>

                        <h3>Super Keyword</h3>
                        <p>Use super() to call the parent class's constructor or methods</p>

                        <pre><code>
                            class Dog extends Animal {
                                constructor(name, breed) {
                                    super(name);
                                    this.breed = breed;
                                }

                                speak() {
                                    super.speak(); // Tommy makes a noise
                                    console.log(`${this.name} barks loudly`);
                                }
                            }
                        </code></pre>

                        <h3>Encapsulation with # (Private fields)</h3>
                        <p>ES2022 introduced fully private data in js.</p>

                        <pre><code>
                            class Account {
                                #balance = 0;

                                deposit(amount) {
                                    this.#balance += amount;
                                }

                                getBalance() {
                                    return this.#balance;
                                }
                            }

                            const a = new Account();
                            a.deposit(100);
                            console.log(a.getBalance()); // 100
                            // a.#balance ❌ Error: private field
                        </code></pre>

                        <h3>Static Methods</h3>
                        <p>static methods are class methods.</p>

                        <pre><code>
                            class MathUtil {
                                static add(a, b) {
                                    return a + b;
                                }
                            }

                            console.log(MathUtil.add(2, 3)); // 5
                        </code></pre>

                        <h3>Object.create() — Direct Prototypal Inheritance</h3>
                        <p>No classes needed — inheritance via prototype directly</p>
                        <pre><code>
                            const human = {
                                sayHi() {
                                    console.log("Hello human");
                                }
                            };

                            const student = Object.create(human);
                            student.name = "Sita";
                            student.sayHi(); // Hello human
                        </code></pre>

                        <h3>Getter and Setter</h3>

                        <pre><code>
                            class Product {
                                #price = 0;

                                constructor(price) {
                                    this.#price = price; // this will use the setter below!
                                }

                                get price() {
                                    return this.#price;
                                }

                                set price(val) {
                                    if (typeof val !== "number" || val < 0) {
                                        throw new Error("Invalid price: must be a non-negative number");
                                    }

                                    this.#price = val;
                                }
                            }
                            const acc = new Product();

                            try {
                                acc.price = -999; // ❌
                            } catch (err) {
                                console.error( 'Error:', err.message );
                            }
                        </code></pre>

                        <h3>Benefits of Getter & Setter</h3>
                        <ul>
                            <li>Constructor = sets up the initial state</li>
                            <li>Getters/Setters = control and manage future access</li>
                            <li>Constructor = One-time Setup. That is: Does not protect or validate future changes</li>
                            <li>A constructor calls the setter if you write this.name = name (it's smart)</li>
                            <li>Private fields (#field) can only be accessed via get/set</li>
                        </ul>

                        <h3>Prototype in JS</h3>
                        <ul>
                            <li>Every object in JavaScript has a property called constructor that references the
                                function used to create it.</li>
                            <li>Every JavaScript object has a hidden property called [[Prototype]], which is a reference
                                to another object.</li>
                            <li>This is how JS does inheritance. No classical classes, no copy-paste of methods — just
                                prototype links.</li>
                            <li>__proto__ is how one object inherits from another.</li>
                            <li>__proto__: The internal link to the prototype object</li>
                            <li>.prototype: Where shared methods go for constructor functions</li>
                            <li>Object.create(proto): Create an object with a specific prototype</li>
                            <li>instance.__proto__: points to → Constructor.prototype</li>
                            <li>Constructor.prototype: contains shared methods like .sayHi()</li>
                            <li>Object.getPrototypeOf(): Gets actual prototype</li>
                        </ul>

                        <pre><code>
                            const user = { name: "Bharat" };
                            console.log(user.__proto__); // 💥 This is the prototype of 'user'

                            function Person(name) {
                                this.name = name;
                            }

                            Person.prototype.sayHi = function () {
                                console.log(`Hi, I'm ${this.name}`);
                            };

                            const p1 = new Person("Ram");
                            p1.sayHi(); // Hi, I'm Ram ✅
                            // sayHi is stored in Person.prototype, and every instance of Person shares it

                            // prototype chain example:
                            const obj = {};
                            console.log(obj.__proto__);               // Object.prototype
                            console.log(obj.__proto__.__proto__);     // null (end of chain)
                        </code></pre>
                    </div>
                </div>

            </section>
        </div>

        <div id="dom">
            <h1>DOM Stuffs</h1>
            <section>
                <p>DOM Stuffs will go here.</p>
            </section>
        </div>

        <div id="projects">
            <h1>Project Stuffs</h1>
            <section>
                <p>Project Stuffs will go here.</p>
            </section>
        </div>

    </main>

    <footer>
        <p>All Rights Reserved.</p>
    </footer>

    <!-- Modal -->
    <div id="descriptionModal" class="modal-overlay">
        <div class="modal-content">
            <span class="close-btn">&times;</span>
            <div class="modal-scroll-content" id="modalBody"></div>
        </div>
    </div>
    <script src="js/scripts.js" async></script>
</body>

</html>